

* IDEA explicit tagging for return based, assignment based, or expression based function body ahead of time

#+begin_src golem
proc foo(a,b): int = a + b # expression based
proc foo(a,b): int { return a + b } # return based, no = op
proc foo(a,b): (result: int) {result = a + b}
#+end_src

* IDEA type expectation EXPR : TYPE

allow arbitrary expressions to have a type signature

examples:

 * ~let x:i64 = a + b~ equivalent to ~let x = (a + b):i64~
 * ~let y = 123456789:i64~
 * ~let z = 123.456:f32~
 * ~let f = foo:proc(f32,f32):f32

This is not a type cast, it is just an annotation for the type checker
to declare the expected type.

Currently every usage of a colon is used to signal an expected type
for a symbol. The idea is to extend this syntax and allow it to be
used for arbitrary expressions. It could be made a universal truth in
golem that ~:~ is always followed by a /TYPEEXPR/

* IDEA dynconst

Name is not final.

Problem:

#+begin_src golem
# with code duplication
proc getItem(a: var Foo, idx: int): var Bar = {...}
proc getItem(a: const Foo, idx: int): const Bar {...}
# without code duplication
proc getItem(a: dynconst Foo, idx: int): dynconstof(a) Bar = {...}
#+end_src

one implementation when /constness/ just needs to be propagated. The
implementation has the restriction to worth with both const and
mutable, arguments.
